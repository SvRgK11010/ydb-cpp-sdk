package NReverseGeocoder.NProto;

message TGeoData {
    required uint64 Magic = 1;
    required uint64 Version = 2;
    optional uint64 Points = 3;
    optional uint64 PointsNumber = 4;
    optional uint64 PointsCrc32 = 5;
    optional uint64 Edges = 6;
    optional uint64 EdgesNumber = 7;
    optional uint64 EdgesCrc32 = 8;
    optional uint64 EdgeRefs = 9;
    optional uint64 EdgeRefsNumber = 10;
    optional uint64 EdgeRefsCrc32 = 11;
    optional uint64 Parts = 12;
    optional uint64 PartsNumber = 13;
    optional uint64 PartsCrc32 = 14;
    optional uint64 Polygons = 15;
    optional uint64 PolygonsNumber = 16;
    optional uint64 PolygonsCrc32 = 17;
    optional uint64 PolygonRefs = 18;
    optional uint64 PolygonRefsNumber = 19;
    optional uint64 PolygonRefsCrc32 = 20;
    optional uint64 Boxes = 21;
    optional uint64 BoxesNumber = 22;
    optional uint64 BoxesCrc32 = 23;
    optional uint64 Blobs = 24;
    optional uint64 BlobsNumber = 25;
    optional uint64 BlobsCrc32 = 26;
    optional uint64 Kvs = 27;
    optional uint64 KvsNumber = 28;
    optional uint64 KvsCrc32 = 29;
    optional uint64 Regions = 30;
    optional uint64 RegionsNumber = 31;
    optional uint64 RegionsCrc32 = 32;
    optional uint64 RawPolygons = 33;
    optional uint64 RawPolygonsNumber = 34;
    optional uint64 RawPolygonsCrc32 = 35;
    optional uint64 RawEdgeRefs = 36;
    optional uint64 RawEdgeRefsNumber = 37;
    optional uint64 RawEdgeRefsCrc32 = 38;
};
